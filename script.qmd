---
title: "Capstone"
subtitle: "TBA"
author: "IVT; JMR"
course: 
    - Fundamentos de Data Science na Saúde: Aplicações com R, Escola Nacional de Saúde Pública
date: today
date-format: long
lang: pt 
bibliography: template/references.bib
format: 
  html:
    smooth-scroll: true
    self-contained: true
    toc: true
    toc-location: left
    embed-resources: true
    number-sections: true
    code_download: true
    code-fold: show
    fig_caption: true
    force_captions: true
    subtitle: ""
    urlcolor: darkblue
    linkcolor: darkblue
    fig_width: 12
    fig_height: 8
    always_allow_html: true
theme:
  light: flatly
  dark: darkly
execute:
  warning: false
  echo: true
  message: false
---

# Índice

-   ver como fazer

# 1. Introdução (Contexto)

> -\[x\] Explique qual base de dados utilizou e descreva as variáveis empregadas, assim como o objetivo da exploração da base de dados.
>
> -   O código de suas análises deve estar visível.
>
> -   Utilize pelo menos 3 funcionalidades do módulo 2 (referências, inline coding, adicionar imagem).

O presente projeto foi desenvolvido no âmbito do **Capstone** do curso [**Fundamentos de Data Science na Saúde: Aplicações com R**](https://www.ensp.unl.pt/curso/fundamentos-de-data-science-na-saude-aplicacoes-com-r/) da [**Escola Nacional de Saúde Pública**](https://www.ensp.unl.pt/) [@ENSP_FundamentosDataScience2025].

![](images/RStudio_logo_flat.svg.png){width="295"} 
Fonte: [@RStudioLogo]

O trabalho tem como propósito aplicar técnicas de ciência de dados na análise de uma base real de morbilidade hospitalar, a base de Grupos de Diagnóstico Homogéneo (GDH) disponibilizada pela Administração Central do Sistema de Saúde (ACSS). A crescente complexidade dos cuidados hospitalares e a transição para o modelo das Unidades Locais de Saúde (ULS) colocam desafios importantes para a gestão integrada dos recursos e para a equidade no acesso. Neste contexto, comparar realidades distintas (como as ULS do Médio Ave e de Amadora-Sintra) permite compreender diferenças territoriais na carga de doença e na resposta dos serviços hospitalares, contribuindo para uma visão mais informada sobre o desempenho do SNS. Assim, este estudo combina análise demográfica, epidemiológica e operacional, explorando a base de dados de internamentos hospitalares (GDH) e relacionando-a com variáveis geográficas e populacionais. O objetivo final é demonstrar o potencial da análise de dados em R como ferramenta de apoio à tomada de decisão em saúde pública e à avaliação do desempenho das ULS.

### A ULS

-   imagem

-   Caracterizar a população residente nas áreas correspondentes às duas ULS (população 2013 ou 2024)

**Bases de dados utilizadas**

-   base_gdh_2017_icd10_no_freg

-   codigos_diagnostico_icd10

-   geo_linkage_2024_v6

-   grupos_gdh

-   INE - Populacao 2017 -

------------------------------------------------------------------------

## 1.2. Objetivos do estudo

## Objetivo geral

Analisar e comparar os padrões de morbilidade hospitalar e a resposta assistencial entre as Unidades Locais de Saúde (ULS) do Médio Ave e Amadora-Sintra, utilizando dados da base de Grupos de Diagnóstico Homogéneo (GDH) do SNS, com foco na caracterização demográfica, perfil de diagnósticos e desempenho hospitalar. Objetivos específicos

1.  ⁠ ⁠Caracterizar a população residente nas áreas correspondentes às duas ULS, segundo idade, sexo e perfil de morbilidade.
2.  Identificar e comparar os principais grupos de diagnósticos (GDH) e condições de saúde mais prevalentes em cada região.
3.  ⁠Avaliar diferenças na resposta hospitalar, considerando:
    1.  tempos médios de internamento por grupo de diagnóstico;
    2.  VALE A PENA??? - ocorrência de reinternamentos;
    3.  limitações de codificação e de qualidade dos dados.

## 2.1. Objetivo geral

O projecto centra-se na análise comparativa da situação nas ULS do Médio Ave e Amadora-Sintra.

## 2.2. Objetivos específicos

-   Caracterizar a população residente nos concelhos correspondentes às áreas das ULS

    -   distribuição idades, sexo

    -   problemas de saúde (total por nível de risco mortalidade e severidade)

-   Caracterizar os problemas de saúde e identificar os mais prevalentes

    -   comparar totais, áreas,

-   Comparar resposta por hospital

    -   tempos de internamento para problemas semelhantes (mesma codificaçao)

        -   decidir se por gcd ou gcd + icd10 - questão codificação está efetivamente correta???

        -   reinternamentos (episodio - alta - episodio - calcular tempo entre episodios ou entre alta e novo episodio) - discutir limitações

        -   

        -   

# 3. Importação e preparação dos dados

```{r}
#| warning: false
#| message: false
#| error: false

set.seed(123)

rm(list = ls(all.names = TRUE)) 
required_packages <- c(
                       "tidyverse",
                       "rio",
                       "scales",
                       "here",
                       "patchwork",
                       "sf", 
                       "ggthemes",
                       "giscoR",
                       "eurostat",
                       "sysfonts", 
                       "showtext", 
                       "scales",
                       "geodata", 
                       "osmdata", 
                       "leaflet",
                       "janitor",
                       "assertr",
                       "data.validator",
                       "forcats",
                       "data.table",
                       "broom",
                       "gt",
                       "gtsummary",
                       "glm2",
                       "performance",
                       "see",
                       "readxl"
                       )      

for (pkg in required_packages) {
 
  if (!pkg %in% rownames(installed.packages())) {
    install.packages(pkg)
  }

  library(pkg, character.only = TRUE)
}
remove(required_packages)
remove(pkg)

```

```{r importation and cleaning}
gdh_base_raw <-  import("data/data_gdh/base_gdh_icd10_no_freg.csv")

code_residence <- import("data/data_gdh/codigos_residencia.csv")

geo_linkage <- import("data/data_gdh/geo_linkage_2024_v6.csv")

comm_pt <- st_read("data/map_json_portugal/concelhos_portugal_light.json")


# residentes_2013 <- read_delim("data/populacao_residente_2013.csv", 
#     delim = ";", 
#     escape_double = FALSE, 
#     trim_ws = TRUE)

icd10_codes <- import("data/data_gdh/codigos_diagnostico_icd10.csv")

gdh_group <- import("data/data_gdh/grupos_gdh.csv")


```

## Limpeza e transformação das variáveis

```{r }


# code_residence <- code_residence |> 
  # clean_names() |> 
  # select(
  #   cod_dist, 
  #   cod_conc,
  #   des_dcf
  # )


comm_pt <- comm_pt |>
  rename(geodsg = NAME_2)


# preparar base dados code_residence e  para join 
# code_residence <- code_residence |> # APAGAR NAO E NECESSARIO
#   mutate(
#     across(c(cod_dist, cod_conc), ~sprintf("%02d", .x), .names = "{.col}_chr"),
#     dt_mun = paste0(cod_dist_chr, cod_conc_chr)
#     )

gdh_base_clean <- gdh_base_raw |> 
  clean_names() |> 
  rename(
    cod_dist = distrito,
    cod_conc = concelho,
    icd10_code = cod_diagnostico
  ) |> 
  mutate(
    across(c(cod_dist, cod_conc), ~sprintf("%02d", .x), .names = "{.col}_chr"),
    dt_mun = paste0(cod_dist_chr, cod_conc_chr),
    code_length = nchar(icd10_code)
    )

icd10_codes_pt <- icd10_codes |> 
  clean_names() |>
  rename(
    descricao_pt = pt,
    descricao_en = short_descp_icd_10_cm, 
    icd10_code = codigo_icd_10_cm
  ) |> 
  select(
    icd10_code,
    descricao_en,
    descricao_pt
  ) |> 
  mutate(
    code_length = nchar(icd10_code)
  ) |> 
  distinct(icd10_code, .keep_all = TRUE)

# identificar duplicados (EXISTIAM!! foi necessario apagar ver distinct())
icd10_codes_pt %>% 
  count(icd10_code, code_length) %>%
  filter(n > 1)

# join gdh group and icd10 codes
gdh_base_join <- gdh_base_clean |> 
  left_join(
    icd10_codes_pt, by = c("icd10_code", "code_length")
  ) |> 
  left_join(
    gdh_group, by = "gcd_apr31"
    )

# join grandes grupos (gcd_apr31)
#verificar duplicados - não há
gdh_group <- gdh_group |> 
  clean_names() |> 
  rename(
    descricao_apr31 = designacao
  )

gdh_group%>% 
  count(gcd_apr31) %>%
  filter(n > 1)



# join concelho e municipio 
# foi necessario criar vetor - passar de int a chr 

geo_linkage <- geo_linkage |>
  mutate(
    dt_mun = str_pad(as.character(dt_mun), 4, pad = 0)
         )
  

geolink_target <- c("dt_mun", "distrito_2013", "municipio_2013", "uls_2024", "regiao_2024", "nuts3_2013", "nuts3_2013_cod", "nuts3_2024", "nuts3_2024_cod", "municipio_2024_cod", "uls_2023", "uls_hierarquia_csp")

geo_linkage_clean <- geo_linkage |> 
  select(all_of(geolink_target)) |> 
  distinct(dt_mun, .keep_all = TRUE)

# residence_geo_join <- geo_linkage_target |> 
  # left_join(
  #   code_residence,
  #   geo_linkage_target,
  #   by = "dt_mun") 

gdh_join_final <- gdh_base_join |> 
  left_join(
    geo_linkage_clean,
    by = "dt_mun") 

# Base de dados apenas com ULS Amadora/Sintra, ULS Médio Ave
gdh_uls <- gdh_join_final |> 
  filter(uls_2024 %in% c("ULS de Amadora/Sintra", "ULS do Médio Ave")) 



# FUNCOES
# distribuicao_idade <- function(data, uls) |> 
#   ggplot() |> 
#   geom_jitter(aes(x = idade, y = dias_internamento, fill = sexo)) +
#   
# p1 <- distribuicao_idade(gdh_base_clean, "uls medio ave")
```

## Documento erros da base e o que fez para os resolver

-   Codigos Municipio Base geo_linkage v6 - mais do que uma entrada para codigo dt_mun

    -   Resoluçao: apagar duplicados, manter apenas um codigo por distrito e concelho

-   

# 4. Análise exploratória dos dados

## Problemas:

-   adm_tip - apenas dois tipos presentes na base de dados (urgente e programado)

-   hora_urgencia, hora_entrada - valores em falta

-   

### Caracterizar a população residente nas áreas correspondentes às duas ULS, segundo idade, sexo

```{r}
# valores únicos 
# hosp_id <- distinct(gdh_base, hosp_id)
# 
# tipo_adm <- distinct(gdh_base, adm_tip)
# 
# patient_id <- distinct(gdh_base, seq_number)
# 
# total_patients <- length(patient_id$seq_number)
# 
# patient_id <- patient_id |> 
#   mutate(
#     age_group = length(patient_id$seq_number)
#   )

# Criar as categorias (European Standard Population (ESP) 2013 e INE) 
gdh_uls <- gdh_uls |> 
  mutate(
    idade_cat_eu = cut(
      idade,
      breaks = c(0, 1, 5, 10, 15, 20, 25, 30, 35, 40, 45,
                 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, Inf),
      right = FALSE), # Criar nova categoria com divisão do grupo etário do Eurostat para análise
      idade_cat_ine = cut(
      idade,
      breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40, 45,
                 50, 55, 60, 65, 70, 75, 80, 85, Inf), 
      right = FALSE) # Criar nova categoria com divisão do grupo etário do INE para análise
  )


# Total Episódios por ULS e Tipo de episodio 
total_ep_uls <- gdh_uls |> 
  group_by(uls_2024, adm_tip) %>%
  summarise(total = n()) %>%
  arrange(uls_2024)

# boxplot ?  


# 
total_uls_sex_age <- gdh_uls |> 
  group_by(uls_2024, adm_tip, sexo = as.factor(sexo), idade_cat_ine) %>%
  summarise(total = n()) %>%
  arrange(uls_2024)


tabela1 <- tbl_summary(
  gdh_uls,
  include = c(uls_2024, adm_tip, sexo, idade_cat_ine),
  by = uls_2024, # Dividir a tabela pelo estado da doença cardíaca
  missing = "ifany", # Excluir dados ausentes do resumo
) |>
  modify_spanning_header(c("stat_1", "stat_2") ~ "**ULS**") %>%
  add_n() |>  # Adicionar uma coluna para contar observações não ausentes
  # add_p() |>  # Realizar testes estatísticos para comparar grupos
  modify_header(label = "**Variável**") |>  # Personalizar o cabeçalho da tabela
  bold_labels() # Tornar as etiquetas em negrito para ênfase

tabela1 <- tabela1 |> 
  as_gt() |>  
  tab_header(
    title = md("**Risco por ULS**") ,
    subtitle = "Por sexo e idade"
  ) |>
  tab_source_note(
    source_note = md("Fonte: gdh")
  ) |>
  fmt_number( decimals = 3) |>   
  opt_stylize(style = 1, color = "gray") |> 
  opt_align_table_header(align = "left") 

tabela1

tabela2 <- tbl_summary(
  gdh_uls,
  include = c(uls_2024, adm_tip, sexo, idade_cat_ine, dsp, descricao_apr31),
  by = uls_2024, # Dividir a tabela pelo estado da doença cardíaca
  missing = "ifany", # Excluir dados ausentes do resumo
) |>
  modify_spanning_header(c("stat_1", "stat_2") ~ "**ULS**") %>%
  add_n() |>  # Adicionar uma coluna para contar observações não ausentes
  # add_p() |>  # Realizar testes estatísticos para comparar grupos
  modify_header(label = "**Variável**") |>  # Personalizar o cabeçalho da tabela
  bold_labels() # Tornar as etiquetas em negrito para ênfase

tabela2 <- tabela2 |> 
  as_gt() |>  
  tab_header(
    title = md("**Risco por ULS**") ,
    subtitle = "Por sexo e idade"
  ) |>
  tab_source_note(
    source_note = md("Fonte: gdh")
  ) |>
  fmt_number( decimals = 3) |>   
  opt_stylize(style = 1, color = "gray") |> 
  opt_align_table_header(align = "left") 

tabela2


# Contar total de observações por grupo etário
contagem_idade <- gdh_uls %>%
  group_by(uls_2024, as.factor(sexo), idade_cat) %>%
  summarise(total = n()) %>%
  arrange(idade_cat)

p4 <- total_ep_uls |> 
  ggplot(aes(x = adm_tip, fill = total)) +  
  geom_bar() + 
  facet_wrap(~uls_2024)  # Dividir o gráfico em facetas com base na variável 'tipo_de_especialidade'

p4


```

```{r}
# Criar tabela resumo 
# escolher variaveis - 


# Distribuição por sexo ULS 
p1 <- gdh_uls |> 
  ggplot(aes(x = uls_2024, fill = sexo)) +
  geom_bar() +
  scale_fill_viridis_d(end = .5) +
  theme(
   # axis.text.y = element_blank(),
    # axis.ticks.y = element_blank(),
    axis.line.x  = element_blank(),
    axis.line.y = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    )

p1
```

### Proporções

```{r}
# grafico barras por uls e severidade problema - considerar fazer dois separados "dodge" 
# como fazer aparecer por percentagens? 

p2 <- gdh_uls |> 
  count(uls_2024, severidade_apr31) |> 
  mutate(freq = (n / sum(n))) |> 
  mutate(cum = cumsum(freq)) |> 
  ggplot(
    aes(x = uls_2024, y = freq, fill = severidade_apr31)
    )+
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_viridis_d(end = .5) +
  geom_text(aes(label = freq), position = position_stack(vjust = .95), colour = "white") +
  labs(fill = "severidade_apr31", y = "Proportion", x = "ULS 2024")

# low hanging fruit: residentes municipio (INE) 2017 - 
# NAs - tirar valores; retirar variaveis?; 
# merge()
# fazer tabela com os missings 

p2
```

## Perfil de morbilidade

```{r}


# total_mort_apr31 <- gdh_uls |>
#   mutate(
#     mort_cat = factor(mortalidade_apr31)
#   ) |> 
#     group_by(uls_2024, mort_cat) |> 
#   summarise(total = n(), .groups = "drop")  |> 
#   arrange(uls_2024)

total_mort_apr31 <- gdh_uls |>
  mutate(
    mortalidade_apr31 = na_if(mortalidade_apr31, ""),         # transforma "" em NA
    mort_cat = fct_explicit_na(factor(mortalidade_apr31), na_level = "NA")
  ) |>
  group_by(uls_2024, mort_cat) |>
  summarise(total = n(), .groups = "drop")

p5 <- total_mort_apr31 |>  
  ggplot(
    aes(x = uls_2024, y = total, fill = mort_cat)
    )+
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_viridis_d(end = 0.5) +
  geom_text(aes(label = total), position = position_stack(vjust = 1), colour = "white") +
  labs(y = "Total de episódios", x = "ULS", fill = "Severidade")

p5

#   group_by(uls_2024, mort_cat) %>%
#   summarise(total = n()) #%>%
# arrange(uls_2024)

# total_mort_apr31 <- gdh_uls |>
#   mutate(
#     mort_cat = ifelse(is.na(mortalidade_apr31), "NA", as.character(mortalidade_apr31)),
#     mort_cat = factor(mort_cat)
#   ) |>
  #

# Freq Mortalidade
p3 <- gdh_uls |> 
  count(uls_2024, mortalidade_apr31) |> 
  mutate(freq = (n / sum(n))) |> 
  mutate(cum = cumsum(freq)) |> 
  ggplot(
    aes(x = uls_2024, y = freq, fill = mortalidade_apr31)
    )+
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_viridis_d(end = 0.5) +
  geom_text(aes(label = freq), position = position_stack(vjust = 1), colour = "white") +
  labs(fill = "mortalidade_apr31", y = "Proportion", x = "ULS 2024")

p3

```

concelho/ULS

```{r}

```

# 5. Visualização dos dados

```{r}

```

# 6. Bibliografia/Referências

::: {#refs}
:::

::: callout-note
A versão deste documento foi atualizada no dia **`r format(Sys.Date(), "%d/%m/%Y")`**.
:::
