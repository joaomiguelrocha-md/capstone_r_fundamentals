---
title: "Capstone"
subtitle: "TBA"
author: "IVT; JMR"
course: 
    - Fundamentos de Data Science na Saúde: Aplicações com R, Escola Nacional de Saúde Pública
date: today
date-format: long
lang: pt 
bibliography: template/references.bib
format: 
  html:
    smooth-scroll: true
    self-contained: true
    toc: true
    toc-location: left
    embed-resources: true
    number-sections: true
    code_download: true
    code-fold: show
    fig_caption: true
    force_captions: true
    subtitle: ""
    urlcolor: darkblue
    linkcolor: darkblue
    fig_width: 12
    fig_height: 8
    always_allow_html: true
theme:
  light: flatly
  dark: darkly
execute:
  warning: false
  echo: true
  message: false
---

# Índice

-   ver como fazer

# 1. Introdução (Contexto)

> -\[x\] Explique qual base de dados utilizou e descreva as variáveis empregadas, assim como o objetivo da exploração da base de dados.
>
> -   O código de suas análises deve estar visível.
>
> -   Utilize pelo menos 3 funcionalidades do módulo 2 (referências, inline coding, adicionar imagem).

O presente projeto foi desenvolvido no âmbito do **Capstone** do curso [**Fundamentos de Data Science na Saúde: Aplicações com R**](https://www.ensp.unl.pt/curso/fundamentos-de-data-science-na-saude-aplicacoes-com-r/) da [**Escola Nacional de Saúde Pública**](https://www.ensp.unl.pt/) [@ENSP_FundamentosDataScience2025].

![](images/RStudio_logo_flat.svg.png){width="295"} Fonte: [@RStudioLogo]

O trabalho tem como propósito aplicar técnicas de ciência de dados na análise de uma base real de morbilidade hospitalar, a base de Grupos de Diagnóstico Homogéneo (GDH) disponibilizada pela Administração Central do Sistema de Saúde (ACSS). A crescente complexidade dos cuidados hospitalares e a transição para o modelo das Unidades Locais de Saúde (ULS) colocam desafios importantes para a gestão integrada dos recursos e para a equidade no acesso. Neste contexto, comparar realidades distintas (como as ULS do Médio Ave e de Amadora-Sintra) permite compreender diferenças territoriais na carga de doença e na resposta dos serviços hospitalares, contribuindo para uma visão mais informada sobre o desempenho do SNS. Assim, este estudo combina análise demográfica, epidemiológica e operacional, explorando a base de dados de internamentos hospitalares (GDH) e relacionando-a com variáveis geográficas e populacionais. O objetivo final é demonstrar o potencial da análise de dados em R como ferramenta de apoio à tomada de decisão em saúde pública e à avaliação do desempenho das ULS.

### A ULS

-   imagem

-   Caracterizar a população residente nas áreas correspondentes às duas ULS (população 2017)

+---------------+--------+---------+
| links imagens | uls as | ulsmave |
|               |        |         |
| uls           |        |         |
+---------------+--------+---------+

Inserir descrição das uls

-   concelhos

-   unidades?

-   densidade populacional .... dados demográficos

```{r}

uls_mave_mun <- c("Santo Tirso", "Trofa", "Vila Nova de Famalicão")
uls_as_mun <- c("Amadora", "Sintra")

theme_map <- function(...) {
  theme_minimal() +                    # Começa com o tema minimalista do ggplot2
  theme(
    axis.line = element_blank(),       # Remove as linhas dos eixos
    axis.text.x = element_blank(),     # Remove o texto do eixo X
    axis.text.y = element_blank(),     # Remove o texto do eixo Y
    axis.ticks = element_blank(),      # Remove os ticks (marcadores) dos eixos
    axis.title.x = element_blank(),    # Remove o título do eixo X
    axis.title.y = element_blank(),    # Remove o título do eixo Y
    panel.grid.major = element_blank(),# Remove as grades principais do painel
    panel.grid.minor = element_blank(),# Remove as grades menores do painel
    panel.border = element_blank(),    # Remove a borda do painel
  )
}

gdh_uls_comm <- comm_pt |> 
  mutate(
    municipio_2013 = geodsg
  ) |> 
  right_join(
    gdh_uls,
    by = "municipio_2013"
  )

uls_map <- ggplot() +
  geom_sf(data = comm_pt,
          aes(fill = NAME_1), 
          size = 0.8,
          colour = NA,
          # color = "darkgray",
          fill = "lightgray"
          ## fill = "white"
  ) +
  geom_sf(data = gdh_uls_comm, 
          aes(fill = municipio_2013),
          size = 0.3,
          color = "black"
  ) +
  labs(x = NULL, 
       y = NULL,
       legend = NULL,
       label = "ULS Amadora/Sintra e ULS Médio Ave"
       # title = "ULS Médio Ave", 
       # subtitle = "2024", 
       # caption = "Data: DGS, 2021"
       ) +
  #scale_fill_discrete(name = "Concelhos") +
  coord_sf() +
  # Ajustar a posição e estilo da legenda
  theme_map() +
  theme(
    legend.title = element_blank(),
    legend.position = "none",
    # legend.position = "right",
    # legend.direction = "vertical",
    legend.text = element_blank() # element_text(size = 8, colour = "gray50")
  )

ggsave("mapa_uls_junto.png", uls_map) 

ulsmave_map <- ggplot() +
  geom_sf(data = subset(comm_pt, geodsg %in% uls_mave_mun), 
          aes(fill = uls_mave_mun), 
          size = 1.0,
          colour = "black"
          # color = "darkgray",
          ## fill = "white"
  ) +
  # geom_sf(data = gdh_uls_comm, 
  #         aes(fill = municipio_2013),
  #         size = 0.3,
  #         color = "black"
  # ) +
  labs(x = NULL,
       y = NULL,
       legend = NULL,
       label = "",
       title = "ULS Médio Ave"
       # subtitle = "",
       # caption = ""
       ) +
  #scale_fill_discrete(name = "Concelhos") +
  coord_sf() +
  # Ajustar a posição e estilo da legenda
  theme_map() +
  theme(
    legend.title = element_blank(),
    legend.position = "none",
    # legend.position = "right",
    # legend.direction = "vertical",
    legend.text = element_blank() # element_text(size = 8, colour = "gray50")
  )

ulsmave_map

ggsave("mapa_uls_mave.png", ulsmave_map) 

subset(comm_pt, geodsg %in% uls_mave_mun)

uls_as_map <- ggplot() +
  geom_sf(data = subset(comm_pt, geodsg %in% uls_as_mun), 
          aes(fill = uls_as_mun), 
          size = 1.0,
          colour = "black"
          # color = "darkgray",
          ## fill = "white"
  ) +
  # geom_sf(data = gdh_uls_comm, 
  #         aes(fill = municipio_2013),
  #         size = 0.3,
  #         color = "black"
  # ) +
  labs(x = NULL,
       y = NULL,
       legend = NULL,
       label = "",
       title = "ULS Amadora Sintra"
       # subtitle = "",
       # caption = ""
       ) +
  #scale_fill_discrete(name = "Concelhos") +
  coord_sf() +
  # Ajustar a posição e estilo da legenda
  theme_map() +
  theme(
    legend.title = element_blank(),
    legend.position = "none",
    # legend.position = "right",
    # legend.direction = "vertical",
    legend.text = element_blank() # element_text(size = 8, colour = "gray50")
  )

uls_as_map

ggsave("mapa_uls_as.png", uls_as_map)

# ! - Falta: - Dados demográficos
## uls com distrito, concelhos e area ars
```

**Bases de dados utilizadas**

-   base_gdh_2017_icd10_no_freg

-   codigos_diagnostico_icd10

-   geo_linkage_2024_v6

-   grupos_gdh

-   INE - Populacao 2017 -

------------------------------------------------------------------------

## 1.2. Objetivos do estudo

## Objetivo geral

Analisar e comparar os padrões de morbilidade hospitalar e a resposta assistencial entre as Unidades Locais de Saúde (ULS) do Médio Ave e Amadora-Sintra, utilizando dados da base de Grupos de Diagnóstico Homogéneo (GDH) do SNS, com foco na caracterização demográfica, perfil de diagnósticos e desempenho hospitalar. Objetivos específicos

1.  ⁠ ⁠Caracterizar a população residente nas áreas correspondentes às duas ULS, segundo idade, sexo e perfil de morbilidade.
2.  Identificar e comparar os principais grupos de diagnósticos (GDH) e condições de saúde mais prevalentes em cada região.
3.  ⁠Avaliar diferenças na resposta hospitalar, considerando:
    1.  tempos médios de internamento por grupo de diagnóstico;
    2.  VALE A PENA??? - ocorrência de reinternamentos;
    3.  limitações de codificação e de qualidade dos dados.

## 2.1. Objetivo geral

O projecto centra-se na análise comparativa da situação nas ULS do Médio Ave e Amadora-Sintra.

## 2.2. Objetivos específicos

-   Caracterizar a população residente nos concelhos correspondentes às áreas das ULS

    -   distribuição idades, sexo

    -   problemas de saúde (total por nível de risco mortalidade e severidade)

-   Caracterizar os problemas de saúde e identificar os mais prevalentes

    -   comparar totais, áreas,

-   Comparar resposta por hospital

    -   tempos de internamento para problemas semelhantes (mesma codificaçao)

        -   decidir se por gcd ou gcd + icd10 - questão codificação está efetivamente correta???

        -   reinternamentos (episodio - alta - episodio - calcular tempo entre episodios ou entre alta e novo episodio) - discutir limitações

        -   

        -   

# 3. Importação e preparação dos dados (Passar a importação de dados e colocar logo no início)

```{r}
#| warning: false
#| message: false
#| error: false

set.seed(123)

rm(list = ls(all.names = TRUE)) 
required_packages <- c(
                       "tidyverse",
                       "rio",
                       "scales",
                       "here",
                       "patchwork",
                       "sf", 
                       "ggthemes",
                       "giscoR",
                       "eurostat",
                       "sysfonts", 
                       "showtext", 
                       "scales",
                       "geodata", 
                       "osmdata", 
                       "leaflet",
                       "janitor",
                       "assertr",
                       "data.validator",
                       "forcats",
                       "data.table",
                       "broom",
                       "gt",
                       "gtsummary",
                       "glm2",
                       "performance",
                       "see",
                       "readxl",
                       "purrr",
                       "tibble"
                       )      

for (pkg in required_packages) {
 
  if (!pkg %in% rownames(installed.packages())) {
    install.packages(pkg)
  }

  library(pkg, character.only = TRUE)
}
remove(required_packages)
remove(pkg)

```

```{r importation and cleaning}
gdh_base_raw <-  import("data/data_gdh/base_gdh_icd10_no_freg.csv")

# code_residence <- import("data/data_gdh/codigos_residencia.csv") 
# Não foi necessário usar 

geo_linkage <- import("data/data_gdh/geo_linkage_2024_v6.csv")

comm_pt <- st_read("data/map_json_portugal/concelhos_portugal_light.json")


# residentes_2013 <- read_delim("data/populacao_residente_2013.csv", 
#     delim = ";", 
#     escape_double = FALSE, 
#     trim_ws = TRUE)

icd10_codes <- import("data/data_gdh/codigos_diagnostico_icd10.csv")

gdh_group <- import("data/data_gdh/grupos_gdh.csv")


```

```{r}

df_summarise <- function(df) {
    tibble(
      variable = names(df),
      type = map_chr(df, ~ class(.x)[1]),
      n_total = nrow(df),
      n_distinct = map_int(df, ~ if (is.character(.x) || is.factor(.x))
                              dplyr::n_distinct(.x, na.rm = TRUE) # especifica package para evitar conflito
                            else NA_integer_),
    n_NA = map_int(df, ~ {
      if (is.character(.x)) {
        sum(is.na(.x) | .x == "", na.rm = TRUE)  # contar NA e células em branco 
      } else {
        sum(is.na(.x))
      }
    })
  )
}


```

```{r}

# Base dados gdh 
# checking for NA
gdh_raw_summary <- df_summarise(gdh_base_raw)

tabela0 <- gdh_raw_summary |> 
  gt()

tabela0

gtsave(tabela0, filename = "gdh_tabela_limpeza.html") 

gdh_unique <- gdh_base_raw |>
  select(where(is.character)) |> 
  map(unique)

gdh_base_raw |> 
  count(
    `tipo_port APR31` == "Amb"
    )

gdh_base_raw |> 
  count(
    `tipo_port APR31` == "Int",
    dias_int == 0 
    ) 
  
total_icd10 <- gdh_join_final |> 
  group_by(icd10_code) |> 
  summarise(total = n()) |>
  arrange(desc(total)) |> 
  right_join(
    icd10_codes_pt,
    by = "icd10_code"
  )

total_icd10 <- gdh_join_final |> 
  group_by(uls_2024, dt_mun, icd10_code) |> 
  summarise(total = n()) |>
  arrange(desc(total)) |> 
  left_join(
    icd10_codes_pt,
    by = "icd10_code"
  )

total_icd10_uls <- gdh_join_final |> 
  group_by(icd10_code, tipo_port_apr31, uls_2024) %>%
  summarise(total = n()) %>%
  arrange(desc(total)) 


gdh |>
  count(
    tipo_port_apr31 == "Amb",
    icd10_code == "Z5111"
  )
  

gdh_join_final_sum <- df_summarise(gdh_join_final)

tabela500 <- gdh_join_final_sum |> 
  gt()

tabela500
```

Avaliação inicial

Total observações vs NA

-   n = 1711879

-   NA

    -   hora_urgencia: n(1.327.998) -

    -   sexo: 3ª categoria - "Indeterminado" contabilizar como NA

    -   severidade: 225 em branco -\> transformar em "desconhecido"

    -   mortalidade 225 em branco -\>

Erros tipo variaveis

-   gcd_apr31 - int devia ser chr

-   concelho e distrito - estão como int - sao codigos numéricos deve ser chr

-   freguesia - remover, sem valores que possamos utilizar

-   

Outros:

-   dias internamento - como interpretar? remover 0?

-   o que seria expectavel (dicionario) vs obs variaveis

    -   adm_tip - apenas dois tipos, mas 0 missings

    -   dsp - como interpretar? tratar falecidos

    -   

```         
seq_number - sem NA 
hosp_id - 56 possiveis - algum missing? 
sexo - 3 variaveis como esperado, 
idade - todas têm entrada - 0 são mesmo idade? se tiver meses? 
distrito - transformar em chr e contar diferentes (30 valores possiveis)
concelho - igual a distrito 
freguesia - inútil - remover 
hora_entrada - valores em s, a partir das 0h do dia da entrada na instituição - verificar 0 e como interpretar  
dias_int - Total de dias de estadia do utente na instituição de saúde, em conformidade com a definição estatística de tempo de internamento, constante na portaria em vigor à data de extração dos dados.- qual a definicao estatistica? 
dsp - 9 valores possiveis, 9 entradas , contar "Desconhecido" como NA 
adm_tip - 8 valores possiveis, apenas 2 
hora_urgência - Hora de entrada no serviço de urgência da instituição de saúde. Os valores são apresentados em segundos, contados a partir das zero horas do dia em que o utente deu entrada, no serviço de urgência da instituição - 
gcd_APR31 - mudar para chr, 27 valores possiveis, 99 - Erro
tipo_port APR31 - 2 possiveis, 0 NA - bem 
severidade_APR31 - mortalidade_APR31 - 4 valores possiveis existem 5 - 225 NA são todos missing
cod_diagnostico - ver se dao todos match com icd10.csv 
```

Fazer o mesmo para restantes bases de dados

```{r}


icd10_summary <- df_summarise(icd10_codes)

tabela01 <- icd10_summary |> 
  gt() 

tabela01 
```

-   todas as variáveis são chr

-   PT: 1180 empty -\> mas descrição em inglês tem valor

```{r}

gdh_group_summary <- df_summarise(gdh_group)

tabela02 <- gdh_group_summary |> 
  gt() 

tabela02



gdh_group_summary <- df_summarise(gdh_group)

tabela02 <- gdh_group_summary |> 
  gt() 

tabela02
```

-   gcd_apr31 - int em vez de chr - transformar

-   

## Limpeza e transformação das variáveis

```{r }




# code_residence <- code_residence |> 
  # clean_names() |> 
  # select(
  #   cod_dist, 
  #   cod_conc,
  #   des_dcf
  # )


comm_pt <- comm_pt |>
  rename(geodsg = NAME_2)


# preparar base dados code_residence e  para join 
# code_residence <- code_residence |> # APAGAR NAO E NECESSARIO
#   mutate(
#     across(c(cod_dist, cod_conc), ~sprintf("%02d", .x), .names = "{.col}_chr"),
#     dt_mun = paste0(cod_dist_chr, cod_conc_chr)
#     )

gdh_base_clean <- gdh_base_raw |> 
  clean_names() |> 
  rename(
    cod_dist = distrito,
    cod_conc = concelho,
    icd10_code = cod_diagnostico
  ) |> 
  mutate(
    across(c(cod_dist, cod_conc), ~sprintf("%02d", .x), .names = "{.col}_chr"),
    dt_mun = paste0(cod_dist_chr, cod_conc_chr),
    code_length = nchar(icd10_code)
    )

icd10_codes_pt <- icd10_codes |> 
  clean_names() |>
  rename(
    descricao_pt = pt,
    descricao_en = short_descp_icd_10_cm, 
    icd10_code = codigo_icd_10_cm
  ) |> 
  select(
    icd10_code,
    descricao_en,
    descricao_pt
  ) |> 
  mutate(
    code_length = nchar(icd10_code)
  ) |> 
  distinct(icd10_code, .keep_all = TRUE)

# identificar duplicados (EXISTIAM!! foi necessario apagar ver distinct())
icd10_codes_pt %>% 
  count(icd10_code, code_length) %>%
  filter(n > 1)

# join grandes grupos (gcd_apr31)
#verificar duplicados - não há
gdh_group <- gdh_group |> 
  clean_names() |> 
  rename(
    descricao_apr31 = designacao
  )

gdh_group%>% 
  count(gcd_apr31) %>%
  filter(n > 1)


# join gdh group and icd10 codes
gdh_base_join <- gdh_base_clean |> 
  left_join(
    icd10_codes_pt, by = c("icd10_code", "code_length")
  ) |> 
  left_join(
    gdh_group, by = "gcd_apr31"
    )




# join concelho e municipio 
# foi necessario criar vetor - passar de int a chr 

geo_linkage <- geo_linkage |>
  mutate(
    dt_mun = str_pad(as.character(dt_mun), 4, pad = 0)
         )
  

geolink_target <- c("dt_mun", "distrito_2013", "municipio_2013", "uls_2024", "regiao_2024", "nuts3_2013", "nuts3_2013_cod", "nuts3_2024", "nuts3_2024_cod", "municipio_2024_cod", "uls_2023", "uls_hierarquia_csp")

geo_linkage_clean <- geo_linkage |> 
  select(all_of(geolink_target)) |> 
  distinct(dt_mun, .keep_all = TRUE)

# residence_geo_join <- geo_linkage_target |> 
  # left_join(
  #   code_residence,
  #   geo_linkage_target,
  #   by = "dt_mun") 

gdh_join_final <- gdh_base_join |> 
  left_join(
    geo_linkage_clean,
    by = "dt_mun") 

# Base de dados apenas com ULS Amadora/Sintra, ULS Médio Ave
gdh_uls <- gdh_join_final |> 
  filter(uls_2024 %in% c("ULS de Amadora/Sintra", "ULS do Médio Ave")) 



# FUNCOES
# distribuicao_idade <- function(data, uls) |> 
#   ggplot() |> 
#   geom_jitter(aes(x = idade, y = dias_internamento, fill = sexo)) +
#   
# p1 <- distribuicao_idade(gdh_base_clean, "uls medio ave")
```

## Documento erros da base e o que fez para os resolver

-   Como não existe código para freguesia, foi necessario apagar codigos duplicados para ficar apenas um por concelho. Como queremos apenas concelho para fazer mapas é indiferente qual a freguesia, interessando apenas um código por cada concelho:

    -   Codigos Municipio Base geo_linkage v6 - mais do que uma entrada para codigo dt_mun

        -   Resoluçao: apagar duplicados, manter apenas um codigo por distrito e concelho

-   

# 4. Análise exploratória dos dados

### Caracterizar a população residente nas áreas correspondentes às duas ULS, segundo idade, sexo

```{r}
# valores únicos 
# hosp_id <- distinct(gdh_base, hosp_id)
# 
# tipo_adm <- distinct(gdh_base, adm_tip)
# 
# patient_id <- distinct(gdh_base, seq_number)
# 
# total_patients <- length(patient_id$seq_number)
# 
# patient_id <- patient_id |> 
#   mutate(
#     age_group = length(patient_id$seq_number)
#   )

# Criar as categorias (European Standard Population (ESP) 2013 e INE) 
gdh_uls <- gdh_uls |> 
  mutate(
    idade_cat_eu = cut(
      idade,
      breaks = c(0, 1, 5, 10, 15, 20, 25, 30, 35, 40, 45,
                 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, Inf),
      right = FALSE), # Criar nova categoria com divisão do grupo etário do Eurostat para análise
      idade_cat_ine = cut(
      idade,
      breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40, 45,
                 50, 55, 60, 65, 70, 75, 80, 85, Inf), 
      right = FALSE) # Criar nova categoria com divisão do grupo etário do INE para análise
  )


# Total Episódios por ULS e Tipo de episodio 
total_ep_uls <- gdh_uls |> 
  group_by(uls_2024, sexo, idade_cat_eu, adm_tip) %>%
  summarise(total = n()) %>%
  arrange(uls_2024)

# boxplot ?  

p10 <- ggplot(
  total_ep_uls, 
  aes(x= idade_cat_eu)
) +
  geom_density(alpha=.4) +
  facet_grid(~uls_2024) +
  labs(title = "Nº Episodios por grupo etário",
       subtitle = "ULS Amadora/Sintra e ULS Médio Ave",
       y = "Densidade",
       x = "Grupo etário", 
       caption = "Autores:") +
  theme_minimal()

p10

p11 <- ggplot() +
  geom_area(
    gdh_uls,
    aes(y = ),
    alpha= 0.4,
    colour = "black",
    stat = "bin") +
  # facet_grid(~uls_2024) +
  labs(title = "Nº Episodios por grupo etário",
       subtitle = "ULS Amadora/Sintra e ULS Médio Ave",
       y = "Densidade",
       x = "Grupo etário", 
       caption = "Autores:") +
  theme_minimal()

p01


```

```{r}

p4_0 <- gdh_uls |> 
  mutate(
    idade_cat = cut(idade, c(0, 18, 65, Inf))
  ) |> 
  ggplot() +
  geom_bar(
    aes(x = uls_2024, fill = idade_cat),
    position = "fill"
  ) +
  geom_text(
    aes(
      x = uls_2024, 
      fill = idade_cat, 
      label = after_stat(count)
      ),
    stat = "count",
    position = position_fill(vjust = 0.5)
    ) +
    theme(
    legend.title = element_blank(),
    legend.position = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
    ) +
  coord_flip() +
  theme_classic() 


p4_0

p4_1 <- gdh_uls |> 
  mutate(
    idade_cat = cut(idade, c(0, 18, 65, Inf))
  ) |>
  ggplot() +
  geom_bar(
    aes(x = uls_2024, fill = idade_cat),
    position = "stack"
  ) +
  geom_text(
    aes(x = uls_2024, fill = idade_cat, label = after_stat(count)),
    stat = "count",
    position = position_stack(vjust = 0.5)
  ) +
  theme_classic() 
  

p4_1

p4_2 <- gdh_uls |> 
  mutate(
    idade_cat = cut(idade, c(0, 18, 65, Inf))
    ) |>
  count(uls_2024, idade_cat) |> 
  mutate(
    prop_total = n/sum(n)
  ) |> 
  ggplot() +
  geom_bar(
    aes(x = uls_2024, y = prop_total, fill = idade_cat),
    position = "fill"
  ) +
  geom_text(
    aes(x = prop_total, fill = idade_cat,
    label = percent(prop_total, accuracy = 1.0)
    ),
    stat = "count",# mostrar %
    position = position_fill(vjust = 0.5)  
  ) +
  theme_classic() 
  

p4_2

p4_2 <- gdh_uls |> 
  mutate(
    idade_cat = cut(idade, c(0, 18, 65, Inf))
  ) |> 
  ggplot() +
  geom_bar(
    aes(x = uls_2024, fill = idade_cat),
    position = "fill"
  ) +
  geom_text(
    stat = "count",
    aes(label = c(after_stat(prop), "(n)")),
    position = position_fill(vjust = 0.5)
  ) +
  theme_classic() +


p4_2

```

```{r}

# Distribuição por sexo ULS 
p03 <- total_ep_uls |> 
  ggplot(aes(x = uls_2024, fill = sexo)) +
  geom_bar() +
  scale_fill_viridis_d(end = .5) +
 # facet_grid(~uls_2024) +
  theme(
   # axis.text.y = element_blank(),
    # axis.ticks.y = element_blank(),
    axis.line.x  = element_blank(),
    axis.line.y = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    )

p03
```

```{r}
{r}
# 
total_uls_sex_age <- gdh_uls |> 
  group_by(uls_2024, adm_tip, sexo = as.factor(sexo), idade_cat_ine) %>%
  summarise(total = n()) %>%
  arrange(uls_2024)


tabela1 <- tbl_summary(
  gdh_uls,
  include = c(uls_2024, adm_tip, sexo, idade_cat_ine),
  by = sexo, # Dividir a tabela pelo estado da doença cardíaca
  missing = "ifany", # Excluir dados ausentes do resumo
) |>
  modify_spanning_header(c("stat_1", "stat_2") ~ "**Sexo**") %>%
  add_n() |>  # Adicionar uma coluna para contar observações não ausentes
  # add_p() |>  # Realizar testes estatísticos para comparar grupos
  modify_header(label = "**Variável**") |>  # Personalizar o cabeçalho da tabela
  bold_labels() # Tornar as etiquetas em negrito para ênfase

tabela1 <- tabela1 |> 
  as_gt() |>  
  tab_header(
    title = md("**Episódios por ULS**") ,
    subtitle = "Por sexo"
  ) |>
  tab_source_note(
    source_note = md("Fonte: gdh")
  ) |>
  fmt_number( decimals = 3) |>   
  opt_stylize(style = 1, color = "gray") |> 
  opt_align_table_header(align = "left") 

tabela1

tabela2 <- tbl_summary(
  gdh_uls,
  include = c(uls_2024, adm_tip, sexo, idade_cat_ine, dsp, descricao_apr31),
  by = uls_2024, # Dividir a tabela pelo estado da doença cardíaca
  missing = "ifany", # Excluir dados ausentes do resumo
) |>
  modify_spanning_header(c("stat_1", "stat_2") ~ "**ULS**") %>%
  add_n() |>  # Adicionar uma coluna para contar observações não ausentes
  # add_p() |>  # Realizar testes estatísticos para comparar grupos
  modify_header(label = "**Variável**") |>  # Personalizar o cabeçalho da tabela
  bold_labels() # Tornar as etiquetas em negrito para ênfase

tabela2 <- tabela2 |> 
  as_gt() |>  
  tab_header(
    title = md("**Risco por ULS**") ,
    subtitle = "Por sexo e idade"
  ) |>
  tab_source_note(
    source_note = md("Fonte: gdh")
  ) |>
  fmt_number( decimals = 3) |>   
  opt_stylize(style = 1, color = "gray") |> 
  opt_align_table_header(align = "left") 

tabela2


# Contar total de observações por grupo etário
contagem_idade <- gdh_uls %>%
  group_by(uls_2024, as.factor(sexo), idade_cat_ine) %>%
  summarise(total = n()) %>%
  arrange(idade_cat_ine)

p4 <- total_ep_uls |> 
  ggplot() +  
  geom_bar(aes(x = adm_tip, y = total, fill = sexo), 
           stat = "identity") + 
  geom_text(
    aes(x = adm_tip, fill = sexo)
    label = "total",
    stat = "identity",
    position = position_stack(vjust = 0.5)
  ) +
  facet_wrap(~uls_2024) +  # Dividir o gráfico em facetas com base na variável 'tipo_de_especialidade'
  theme_classic()

p4
```

### Proporções

```{r}
# grafico barras por uls e severidade problema - considerar fazer dois separados "dodge" 
# como fazer aparecer por percentagens? 

p2 <- gdh_uls |> 
  count(uls_2024, severidade_apr31) |> 
  mutate(freq = (n / sum(n))) |> 
  mutate(cum = cumsum(freq)) |> 
  ggplot(
    aes(x = uls_2024, y = freq, fill = severidade_apr31)
    )+
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_viridis_d(end = .5) +
  geom_text(aes(label = percent(freq, accuracy = .1)), position = position_stack(vjust = .1), colour = "white") +
  labs(fill = "severidade_apr31", y = "Proportion", x = "ULS 2024")

# low hanging fruit: residentes municipio (INE) 2017 - 
# NAs - tirar valores; retirar variaveis?; 
# merge()
# fazer tabela com os missings 

p2


## !!! transformar em função  
```

## Perfil de morbilidade

```{r}


# total_mort_apr31 <- gdh_uls |>
#   mutate(
#     mort_cat = factor(mortalidade_apr31)
#   ) |> 
#     group_by(uls_2024, mort_cat) |> 
#   summarise(total = n(), .groups = "drop")  |> 
#   arrange(uls_2024)

total_mort_apr31 <- gdh_uls |>
  mutate(
    mortalidade_apr31 = na_if(mortalidade_apr31, ""),         # transforma "" em NA
    mort_cat = fct_explicit_na(factor(mortalidade_apr31), na_level = "NA")
  ) |>
  group_by(uls_2024, mort_cat) |>
  summarise(total = n(), .groups = "drop")

p5 <- total_mort_apr31 |>  
  ggplot(
    aes(x = uls_2024, y = total, fill = mort_cat)
    )+
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_viridis_d(end = 0.5) +
  geom_text(aes(label = total), position = position_stack(vjust = 1), colour = "white") +
  labs(y = "Total de episódios", x = "ULS", fill = "Severidade")

p5

#   group_by(uls_2024, mort_cat) %>%
#   summarise(total = n()) #%>%
# arrange(uls_2024)

# total_mort_apr31 <- gdh_uls |>
#   mutate(
#     mort_cat = ifelse(is.na(mortalidade_apr31), "NA", as.character(mortalidade_apr31)),
#     mort_cat = factor(mort_cat)
#   ) |>
  #

# Freq Mortalidade
p3 <- gdh_uls |> 
  count(uls_2024, mortalidade_apr31) |> 
  mutate(freq = (n / sum(n))) |> 
  mutate(cum = cumsum(freq)) |> 
  ggplot(
    aes(x = uls_2024, y = freq, fill = mortalidade_apr31)
    )+
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_viridis_d(end = 0.5) +
  geom_text(aes(label = freq), position = position_stack(vjust = 1), colour = "white") +
  labs(fill = "mortalidade_apr31", y = "Proportion", x = "ULS 2024")

p3

```

# 5. Visualização dos dados

```{r}

```

# 6. Bibliografia/Referências

::: {#refs}
:::

::: callout-note
A versão deste documento foi atualizada no dia **`r format(Sys.Date(), "%d/%m/%Y")`**.
:::
