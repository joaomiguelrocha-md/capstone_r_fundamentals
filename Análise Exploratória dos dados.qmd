---
title: "Análise Exploratória dos dados"
format: html
editor: visual
---

::: callout-important
Tarefas

-   [ ] Limpeza variáveis

    -   [ ] Idade - (-1) ?

-   [ ] Verificar joins

-   [ ] Variabilidade/distribuição

    -   [ ] valores típicos

    -   [ ] outliers

-   [ ] variavéis

    -   [ ] idade

    -   [ ] sexo

    -   [ ] tempo de internamento

    -   [ ] tipo adm

    -   [ ] destino alta

    -   [ ] códigos/diagnósticos + freq (top 5)

<!-- -->

-   [ ] covariation

    -   [ ] Idade e sexo

    -   [ ] idade tempo internamento

    -   [ ] sexo e tempo internamento

    -   [ ] outras? concelho/uls?

**Covariation** is the tendency for the values of two or more variables to vary together in a related way. The best way to spot covariation is to visualize the relationship between two or more variables.
:::

------------------------------------------------------------------------

## Funções utilizadas nesta secção 

```{r}

df_summarise <- function(df) {
    tibble(
      variable = names(df),
      type = map_chr(df, ~ class(.x)[1]),
      n_total = nrow(df),
      n_distinct = map_int(df, ~ if (is.character(.x) || is.factor(.x))
                              dplyr::n_distinct(.x, na.rm = TRUE) # especifica package para evitar conflito
                            else NA_integer_),
    n_NA = map_int(df, ~ {
      if (is.character(.x)) {
        sum(is.na(.x) | .x == "", na.rm = TRUE)  # contar NA e células em branco 
      } else {
        sum(is.na(.x))
      }
    })
  )
}


```

```{r}
{r}
# Funções 
## Mudar para português

var_summarise <- summarise_variable <- function(x) {
  if (is.numeric(x)) {
    out <- list(
      Min = min(x, na.rm = TRUE),
      Max = max(x, na.rm = TRUE),
      Mean = mean(x, na.rm = TRUE),
      Median = median(x, na.rm = TRUE),
      Quantiles = quantile(x, na.rm = TRUE),
      Total = sum(x, na.rm = TRUE),
      NAs = sum(is.na(x))
    )
  } else if (is.character(x) || is.factor(x)) {
    tbl <- table(x, useNA = "ifany")
    freq <- as.numeric(tbl)
    prop <- as.numeric(prop.table(tbl))
    cum_freq <- cumsum(freq)
    names(freq) <- names(prop) <- names(tbl)
    out <- list(
      Unique_Values = unique(na.omit(x)),
      Frequency = freq,
      Proportion = prop,
      CumFreq = cum_freq,
      NAs = sum(is.na(x))
    )
  } else {
    out <- list(Warning = "Variable type not supported")
  }
  return(out)
}

var_summarise_df <- function(df, x) {
  # Extract the variable vector from df using x as column name (string)
  var <- df[[x]]
  
  if (is.numeric(var)) {
    df_out <- data.frame(
      Statistic = c("Min", "Max", "Mean", "Median", "Total", "NAs"),
      Value = c(
        min(var, na.rm = TRUE),
        max(var, na.rm = TRUE),
        mean(var, na.rm = TRUE),
        median(var, na.rm = TRUE),
        sum(var, na.rm = TRUE),
        sum(is.na(var))
      )
    )
    # Add quantiles as separate rows
    quants <- quantile(var, na.rm = TRUE)
    quant_df <- data.frame(
      Statistic = paste0("Quantile_", names(quants)),
      Value = as.numeric(quants)
    )
    df_out <- rbind(df_out, quant_df)
  } else if (is.character(var) || is.factor(var)) {
    tbl <- table(var, useNA = "ifany")
    freq <- as.numeric(tbl)
    prop <- prop.table(tbl)
    cum_freq <- cumsum(freq)
    df_out <- data.frame(
      Value = names(tbl),
      Frequency = freq,
      Proportion = prop,
      CumFrequency = cum_freq
    )
  } else {
    df_out <- data.frame(Warning = "Variable type not supported")
  }
  
  return(df_out)
}
```

------------------------------------------------------------------------

# Análise Exploratória 

## A Base Gdh e variáveis 

```{r}

# Base dados gdh 
# checking for NA
gdh_raw_summary <- df_summarise(gdh_base_raw)

tabela0 <- gdh_raw_summary |> 
  gt()

tabela0

gtsave(tabela0, filename = "gdh_tabela_limpeza.html") 


```

Avaliação inicial

Total observações vs NA

-   n = 1711879

-   NAs

    -   hora_urgencia: n(1.327.998) - vamos usar? se não apagar

    -   severidade: 225 em branco -\> transformar em "desconhecido"

    -   mortalidade 225 em branco -\> "NA" - transformar em desconhecido para proporções

Erros tipo variaveis

-   gcd_apr31 - int devia ser chr

-   concelho e distrito - estão como int - sao codigos numéricos deve ser chr

-   freguesia - remover, sem valores que possamos utilizar

```{r}

# mapeia categorias de variávies chr 

gdh_unique <- gdh_base_raw |>
  select(where(is.character)) |> 
  map(unique)


gdh |>
  count(
    tipo_port_apr31 == "Amb",
    icd10_code == "Z5111"
  )
  

gdh_join_final_sum <- df_summarise(gdh_join_final)

tabela500 <- gdh_join_final_sum |> 
  gt()

tabela500
```

Outros:

-   dias internamento - como interpretar? remover 0?

-   o que seria expectavel (dicionario) vs obs variaveis

    -   adm_tip - apenas dois tipos, mas 0 missings

    -   dsp - como interpretar? tratar falecidos

    -   

```         
seq_number - sem NA 
hosp_id - 56 possiveis - algum missing? 
sexo - 3 variaveis como esperado, 
idade - todas têm entrada - 0 são mesmo idade? se tiver meses? 
distrito - transformar em chr e contar diferentes (30 valores possiveis)
concelho - igual a distrito 
freguesia - inútil - remover 
hora_entrada - valores em s, a partir das 0h do dia da entrada na instituição - verificar 0 e como interpretar  
dias_int - Total de dias de estadia do utente na instituição de saúde, em conformidade com a definição estatística de tempo de internamento, constante na portaria em vigor à data de extração dos dados.- qual a definicao estatistica? 
dsp - 9 valores possiveis, 9 entradas , contar "Desconhecido" como NA 
adm_tip - 8 valores possiveis, apenas 2 
hora_urgência - Hora de entrada no serviço de urgência da instituição de saúde. Os valores são apresentados em segundos, contados a partir das zero horas do dia em que o utente deu entrada, no serviço de urgência da instituição - 
gcd_APR31 - mudar para chr, 27 valores possiveis, 99 - Erro
tipo_port APR31 - 2 possiveis, 0 NA - bem 
severidade_APR31 - mortalidade_APR31 - 4 valores possiveis existem 5 - 225 NA são todos missing
cod_diagnostico - ver se dao todos match com icd10.csv 
```

Fazer o mesmo para restantes bases de dados

### ICD10 

```{r}


icd10_summary <- df_summarise(icd10_codes)

tabela01 <- icd10_summary |> 
  gt() 

tabela01 

total_icd10 <- gdh_join_final |> 
  group_by(icd10_code) |> 
  summarise(total = n()) |>
  arrange(desc(total)) |> 
  right_join(
    icd10_codes_pt,
    by = "icd10_code"
  )

total_icd10 <- gdh_join_final |> 
  group_by(uls_2024, dt_mun, icd10_code) |> 
  summarise(total = n()) |>
  arrange(desc(total)) |> 
  left_join(
    icd10_codes_pt,
    by = "icd10_code"
  )

total_icd10_uls <- gdh_join_final |> 
  group_by(icd10_code, tipo_port_apr31, uls_2024) %>%
  summarise(total = n()) %>%
  arrange(desc(total)) 
```

-   todas as variáveis são chr

-   PT: 1180 empty -\> mas descrição em inglês tem valor

```{r}

gdh_group_summary <- df_summarise(gdh_group)

tabela02 <- gdh_group_summary |> 
  gt() 

tabela02



gdh_group_summary <- df_summarise(gdh_group)

tabela02 <- gdh_group_summary |> 
  gt() 

tabela02
```

-   gcd_apr31 - int em vez de chr - transformar

## Limpeza e transformação das variáveis

```{r }




# code_residence <- code_residence |> 
  # clean_names() |> 
  # select(
  #   cod_dist, 
  #   cod_conc,
  #   des_dcf
  # )


comm_pt <- comm_pt |>
  rename(geodsg = NAME_2)


# preparar base dados code_residence e  para join 
code_residence <- code_residence |> # APAGAR NAO E NECESSARIO
  clean_names() |> 
  mutate(
    across(c(cod_dist, cod_conc), ~sprintf("%02d", .x), .names = "{.col}_chr"),
    dt_mun = paste0(cod_dist_chr, cod_conc_chr)
    )

gdh_base_clean <- gdh_base_raw |> 
  clean_names() |> 
  filter( 
    idade != -1
    ) |> 
  rename(
    cod_dist = distrito,
    cod_conc = concelho,
    icd10_code = cod_diagnostico
  ) |> 
  mutate(
    across(c(cod_dist, cod_conc), ~sprintf("%02d", .x), .names = "{.col}_chr"),
    dt_mun = paste0(cod_dist_chr, cod_conc_chr),
    code_length = nchar(icd10_code)
    )


# CÓDIGOS RESIDÊNCIA 
gdh_base_join <- gdh_base_clean |> 
  left_join(
    code_residence,
    by = "dt_mun"
  )

icd10_codes_pt <- icd10_codes |> 
  clean_names() |>
  rename(
    descricao_pt = pt,
    descricao_en = short_descp_icd_10_cm, 
    icd10_code = codigo_icd_10_cm
  ) |> 
  select(
    icd10_code,
    descricao_en,
    descricao_pt
  ) |> 
  mutate(
    code_length = nchar(icd10_code)
  ) |> 
  distinct(icd10_code, .keep_all = TRUE)

# identificar duplicados (EXISTIAM!! foi necessario apagar ver distinct())
icd10_codes_pt %>% 
  count(icd10_code, code_length) %>%
  filter(n > 1)

# GDH GROUP
## join grandes grupos (gcd_apr31)
## verificar duplicados - não há
gdh_group <- gdh_group |> 
  clean_names() |> 
  rename(
    descricao_apr31 = designacao
  )

gdh_group%>% 
  count(gcd_apr31) %>%
  filter(n > 1)


# join gdh group and icd10 codes
gdh_base_join <- gdh_base_clean |> 
  left_join(
    icd10_codes_pt, by = c("icd10_code", "code_length")
  ) |> 
  left_join(
    gdh_group, by = "gcd_apr31"
    )




# join concelho e municipio 
# foi necessario criar vetor - passar de int a chr 
# geo_linkage - filtrar repetidos (concelho) para join

geo_linkage <- geo_linkage |>
  mutate(
    dt_mun = str_pad(as.character(dt_mun), 4, pad = 0),
    mun_cod = str_pad(as.character(municipio_2013_cod), 2, pad = 0),
    dt_cod = str_pad(as.character(distrito_2013_cod), 2, pad = 0)
    )
  

geolink_target <- c("dt_mun", "distrito_2013", "municipio_2013", "uls_2024", "regiao_2024", "nuts3_2013", "nuts3_2013_cod", "nuts3_2024", "nuts3_2024_cod", "municipio_2024_cod", "uls_2023", "uls_hierarquia_csp")

geo_linkage_join <- geo_linkage |> 
  select(all_of(geolink_target)) |> 
  distinct(dt_mun, .keep_all = TRUE)

# residence_geo_join <- geo_linkage_target |> 
  # left_join(
  #   code_residence,
  #   geo_linkage_target,
  #   by = "dt_mun") 

gdh_join_final <- gdh_base_join |> 
  left_join(
    geo_linkage_join,
    by = "dt_mun") 

# Base de dados apenas com ULS Amadora/Sintra, ULS Médio Ave
gdh_uls <- gdh_join_final |>
  filter(
    cod_dist != 99
  ) |> 
  filter(uls_2024 %in% c("ULS de Amadora/Sintra", "ULS do Médio Ave")) 



# FUNCOES
# distribuicao_idade <- function(data, uls) |> 
#   ggplot() |> 
#   geom_jitter(aes(x = idade, y = dias_internamento, fill = sexo)) +
#   
# p1 <- distribuicao_idade(gdh_base_clean, "uls medio ave")
```

## Documento erros da base e o que fez para os resolver

-   Como não existe código para freguesia, foi necessario apagar codigos duplicados para ficar apenas um por concelho. Como queremos apenas concelho para fazer mapas é indiferente qual a freguesia, interessando apenas um código por cada concelho:

    -   Codigos Municipio Base geo_linkage v6 - mais do que uma entrada para codigo dt_mun

        -   Resoluçao: apagar duplicados, manter apenas um codigo por distrito e concelho

-   

# 4. Análise exploratória dos dados

### Idade 

```{r}
# variabilidade 

idade_sumario <- var_summarise_df(gdh_base_clean, "idade")

# Base dados completa
p4_0 <- gdh_base_clean |>
  ggplot() +
  geom_boxplot(
    aes(y = idade)
    ) +
  # facet_grid(~sexo) +
  theme_minimal() +
  theme(
    axis.line.x = element_blank(),
    axis.text.x = element_blank()
  )
  
p4

idade_sumario <- idade_sumario |> 
  mutate(
    value = round(Value, 0)
  ) |> 
  filter(
    Statistic != "Total"
  )

# add labels - ver como corrigir 
p4_01 <- gdh_base_clean |>
  ggplot() +
  geom_boxplot(
    aes(x = 1, y = idade)
    ) +
  geom_text(
    data = idade_sumario, 
    aes(x = 1, y = value, label = value),
    hjust = -0.3,
    vjust = -0.3
    ) + 
  coord_flip() + 
  theme_minimal() +
  theme(
    axis.line.x = element_blank(),
    axis.text.x = element_blank()
  )
  
p4_01


# ULS MAve e ULS A/S


p4_02 <- gdh_base_clean |>
  filter(
    sexo != "Indeterminado"
  ) |>
  ggplot() +
  geom_density(
    aes(x = idade)
    ) +
  facet_grid(~sexo) +
  theme_minimal() 
  # theme(
  #   axis.line.x = element_blank(),
  #   axis.text.x = element_blank()
  # )
  
p4_02


# 

# p4_03 <- gdh_base_clean |>
#   filter(
#     sexo != "Indeterminado"
#   ) |>
#   ggplot() +
#   geom_density(
#     aes(x = idade)
#     ) +
#   geom_boxplot(
#     aes(x = idade, y = 0.5)
#     ) +
#   geom_text(
#     data = idade_sumario, 
#     aes(x = value, y = 0.5, label = value),
#     hjust = -0.3,
#     vjust = -0.3
#     ) + 
#   theme_minimal() 
#   # theme(
#   #   axis.line.x = element_blank(),
#   #   axis.text.x = element_blank()
#   # )
#   
# p4_03
```

Sexo

```{r}

sexo_sumario <- var_summarise_df(gdh_base_clean, "sexo")

# Base dados completa
p4_1 <- gdh_base_clean |>
  filter(
    sexo != "Indeterminado"
  ) |> 
  ggplot() +
  geom_boxplot(
    aes(y = idade, fill = sexo)
    ) +
  geom_boxplot(
    aes(x = 1, y = idade)
    ) +
  geom_text(
    data = idade_sumario, 
    aes(x = 1, y = value, label = value),
    hjust = -0.3,
    vjust = -0.3
    ) + 
  theme_classic() +
  theme(
    axis.line.x = element_blank(),
    axis.text.x = element_blank()
  )
  
p4_1

# Ficava mais bonito ribbon 


```

### Caracterizar a população residente nas áreas correspondentes às duas ULS

### idade

### 

```{r}
# valores únicos 
# hosp_id <- distinct(gdh_base, hosp_id)
# 
# tipo_adm <- distinct(gdh_base, adm_tip)
# 
# patient_id <- distinct(gdh_base, seq_number)
# 
# total_patients <- length(patient_id$seq_number)
# 
# patient_id <- patient_id |> 
#   mutate(
#     age_group = length(patient_id$seq_number)
#   )

# Criar as categorias (European Standard Population (ESP) 2013 e INE) 
gdh_uls <- gdh_uls |> 
  mutate(
    idade_cat_eu = cut(
      idade,
      breaks = c(0, 1, 5, 10, 15, 20, 25, 30, 35, 40, 45,
                 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, Inf),
      right = FALSE), # Criar nova categoria com divisão do grupo etário do Eurostat para análise
      idade_cat_ine = cut(
      idade,
      breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40, 45,
                 50, 55, 60, 65, 70, 75, 80, 85, Inf), 
      right = FALSE) # Criar nova categoria com divisão do grupo etário do INE para análise
  )


# Total Episódios por ULS e Tipo de episodio 
total_ep_uls <- gdh_uls |> 
  group_by(uls_2024, sexo, idade_cat_eu, adm_tip) %>%
  summarise(total = n()) %>%
  arrange(uls_2024)

# boxplot ?  

p10 <- ggplot(
  total_ep_uls, 
  aes(x= idade_cat_eu)
) +
  geom_density(alpha=.4) +
  facet_grid(~uls_2024) +
  labs(title = "Nº Episodios por grupo etário",
       subtitle = "ULS Amadora/Sintra e ULS Médio Ave",
       y = "Densidade",
       x = "Grupo etário", 
       caption = "Autores:") +
  theme_minimal()

p10

p11 <- ggplot() +
  geom_area(
    gdh_uls,
    aes(y = ),
    alpha= 0.4,
    colour = "black",
    stat = "bin") +
  # facet_grid(~uls_2024) +
  labs(title = "Nº Episodios por grupo etário",
       subtitle = "ULS Amadora/Sintra e ULS Médio Ave",
       y = "Densidade",
       x = "Grupo etário", 
       caption = "Autores:") +
  theme_minimal()

p01


```

```{r}

gdh_uls <- gdh_join_final |>
  filter(
    cod_dist != 99
  ) |> 
  filter(uls_2024 %in% c("ULS de Amadora/Sintra", "ULS do Médio Ave")) 

p4_0 <- gdh_uls |> 
  mutate(
    idade_cat = cut(idade, c(0, 18, 65, Inf), right = FALSE)
  ) |> 
  group_by(idade_cat) |> 
  ggplot() +
  geom_bar(
    aes(x = uls_2024, fill = idade_cat),
    position = "fill"
  ) +
  geom_text(
    aes(
      x = uls_2024, 
      fill = idade_cat, 
      label = after_stat(count)
      ),
    stat = "count",
    position = position_fill(vjust = 0.5)
    ) +
    theme(
    legend.title = element_blank(),
    legend.position = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
    ) +
  coord_flip() +
  theme_classic() 


p4_0

gdh_uls_check <- gdh_uls |> 
  mutate(
    idade_cat = cut(idade, c(0, 18, 65, Inf))
  ) |> 
  group_by(idade_cat)

p4_1 <- gdh_uls |> 
  mutate(
    idade_cat = cut(idade, c(0, 18, 65, Inf), right = FALSE)
  ) |>
  ggplot() +
  geom_bar(
    aes(x = uls_2024, fill = idade_cat),
    position = "stack"
  ) +
  geom_text(
    aes(x = uls_2024, fill = idade_cat, label = after_stat(count)),
    stat = "count",
    position = position_stack(vjust = 0.5)
  ) +
  theme_classic() 
  

p4_1

## Idade total por  ULS 
p4_2 <- gdh_uls |> 
  mutate(
    idade_cat = cut(idade, c(0, 18, 65, Inf), right = FALSE)
    ) |>
  count(uls_2024, idade_cat) |> 
  mutate(
    prop_total = n/sum(n)
  ) |> 
  ggplot() +
  geom_bar(
    aes(x = uls_2024, y = prop_total, fill = idade_cat),
    position = "fill"
  ) +
  geom_text(
    aes(x = prop_total, fill = idade_cat,
    label = percent(prop_total, accuracy = 1.0)
    ),
    stat = "count",# mostrar %
    position = position_fill(vjust = 0.5)  
  ) +
  theme_classic() 
  

p4_2

p4_2 <- gdh_uls |> 
  mutate(
    idade_cat = cut(idade, c(0, 18, 65, Inf), right = FALSE)
  ) |> 
  ggplot() +
  geom_bar(
    aes(x = uls_2024, fill = idade_cat),
    position = "fill"
  ) +
  geom_text(
    stat = "count",
    aes(label = c(after_stat(prop), "(n)")),
    position = position_fill(vjust = 0.5)
  ) +
  theme_classic() 


p4_2

```

### sexo

```{r}

# Distribuição por sexo ULS 
p03 <- total_ep_uls |> 
  ggplot(aes(x = uls_2024, fill = sexo)) +
  geom_bar(position = "fill") +
  scale_fill_viridis_d(end = .5) +
 # facet_grid(~uls_2024) +
  theme(
   # axis.text.y = element_blank(),
    # axis.ticks.y = element_blank(),
    axis.line.x  = element_blank(),
    axis.line.y = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    )

p03
```

```{r}
{r}
# 
total_uls_sex_age <- gdh_uls |> 
  group_by(uls_2024, adm_tip, sexo = as.factor(sexo), idade_cat_ine) %>%
  summarise(total = n()) %>%
  arrange(uls_2024)


tabela1 <- tbl_summary(
  gdh_uls,
  include = c(uls_2024, adm_tip, sexo, idade_cat_ine),
  by = sexo, # Dividir a tabela pelo estado da doença cardíaca
  missing = "ifany", # Excluir dados ausentes do resumo
) |>
  modify_spanning_header(c("stat_1", "stat_2") ~ "**Sexo**") %>%
  add_n() |>  # Adicionar uma coluna para contar observações não ausentes
  # add_p() |>  # Realizar testes estatísticos para comparar grupos
  modify_header(label = "**Variável**") |>  # Personalizar o cabeçalho da tabela
  bold_labels() # Tornar as etiquetas em negrito para ênfase

tabela1 <- tabela1 |> 
  as_gt() |>  
  tab_header(
    title = md("**Episódios por ULS**") ,
    subtitle = "Por sexo"
  ) |>
  tab_source_note(
    source_note = md("Fonte: gdh")
  ) |>
  fmt_number( decimals = 3) |>   
  opt_stylize(style = 1, color = "gray") |> 
  opt_align_table_header(align = "left") 

tabela1


## Deixar por sexo, retirar esta 
# tabela2 <- tbl_summary(
#   gdh_uls,
#   include = c(uls_2024, adm_tip, sexo, idade_cat_ine, dsp, descricao_apr31),
#   by = uls_2024, # Dividir a tabela pelo estado da doença cardíaca
#   missing = "ifany", # Excluir dados ausentes do resumo
# ) |>
#   modify_spanning_header(c("stat_1", "stat_2") ~ "**ULS**") %>%
#   add_n() |>  # Adicionar uma coluna para contar observações não ausentes
#   # add_p() |>  # Realizar testes estatísticos para comparar grupos
#   modify_header(label = "**Variável**") |>  # Personalizar o cabeçalho da tabela
#   bold_labels() # Tornar as etiquetas em negrito para ênfase
# 
# tabela2 <- tabela2 |> 
#   as_gt() |>  
#   tab_header(
#     title = md("**Risco por ULS**") ,
#     subtitle = "Por sexo e idade"
#   ) |>
#   tab_source_note(
#     source_note = md("Fonte: gdh")
#   ) |>
#   fmt_number( decimals = 3) |>   
#   opt_stylize(style = 1, color = "gray") |> 
#   opt_align_table_header(align = "left") 
# 
# tabela2


# Contar total de observações por grupo etário
contagem_idade <- gdh_uls %>%
  group_by(uls_2024, as.factor(sexo), idade_cat_ine) %>%
  summarise(total = n()) %>%
  arrange(idade_cat_ine)

p4 <- total_ep_uls |> 
  ggplot() +  
  geom_bar(aes(x = adm_tip, y = total, fill = sexo), 
           stat = "identity") + 
  geom_text(
    aes(x = adm_tip, fill = sexo)
    label = "total",
    stat = "identity",
    position = position_stack(vjust = 0.5)
  ) +
  facet_wrap(~uls_2024) +  # Dividir o gráfico em facetas com base na variável 'tipo_de_especialidade'
  theme_classic()

p4
```

### Proporções

```{r}
# grafico barras por uls e severidade problema - considerar fazer dois separados "dodge" 
# como fazer aparecer por percentagens? 

p2 <- gdh_uls |> 
  count(uls_2024, severidade_apr31) |> 
  mutate(freq = (n / sum(n))) |> 
  mutate(cum = cumsum(freq)) |> 
  ggplot(
    aes(x = uls_2024, y = freq, fill = severidade_apr31)
    )+
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_viridis_d(end = .5) +
  geom_text(aes(label = percent(freq, accuracy = .1)), position = position_stack(vjust = .1), colour = "white") +
  labs(fill = "severidade_apr31", y = "Proportion", x = "ULS 2024")

# low hanging fruit: residentes municipio (INE) 2017 - 
# NAs - tirar valores; retirar variaveis?; 
# merge()
# fazer tabela com os missings 

p2


## !!! transformar em função  
```

## Perfil de morbilidade

```{r}


# total_mort_apr31 <- gdh_uls |>
#   mutate(
#     mort_cat = factor(mortalidade_apr31)
#   ) |> 
#     group_by(uls_2024, mort_cat) |> 
#   summarise(total = n(), .groups = "drop")  |> 
#   arrange(uls_2024)

total_mort_apr31 <- gdh_uls |>
  mutate(
    mortalidade_apr31 = na_if(mortalidade_apr31, ""),         # transforma "" em NA
    mort_cat = fct_explicit_na(factor(mortalidade_apr31), na_level = "NA")
  ) |>
  group_by(uls_2024, mort_cat) |>
  summarise(total = n(), .groups = "drop")

p5 <- total_mort_apr31 |>  
  ggplot(
    aes(x = uls_2024, y = total, fill = mort_cat)
    )+
  geom_bar(position = "stack", stat = "identity") +
  scale_fill_viridis_d(end = 0.5) +
  geom_text(aes(label = total), position = position_stack(vjust = 1), colour = "white") +
  labs(y = "Total de episódios", x = "ULS", fill = "Severidade")

p5

#   group_by(uls_2024, mort_cat) %>%
#   summarise(total = n()) #%>%
# arrange(uls_2024)

# total_mort_apr31 <- gdh_uls |>
#   mutate(
#     mort_cat = ifelse(is.na(mortalidade_apr31), "NA", as.character(mortalidade_apr31)),
#     mort_cat = factor(mort_cat)
#   ) |>
  #

# Freq Mortalidade
p3 <- gdh_uls |> 
  count(uls_2024, mortalidade_apr31) |> 
  mutate(freq = (n / sum(n))) |> 
  mutate(cum = cumsum(freq)) |> 
  ggplot(
    aes(x = uls_2024, y = freq, fill = mortalidade_apr31)
    )+
  geom_bar(position = "fill", stat = "identity") +
  scale_fill_viridis_d(end = 0.5) +
  geom_text(aes(label = percent(freq, 1), (vjust = 1), colour = "white")) +
  labs(fill = "mortalidade_apr31", y = "Proportion", x = "ULS 2024")

p3

```

# 

```{r}


gdh_ridges <- gdh_base_join |> 
  left_join(
    geo_linkage_join,
    by = "dt_mun"
  )

anti_join(gdh_base_join, geo_linkage_join, by = "dt_mun")

# nem todos tinham distrito/municipio, havia NA 
gdh_ridges_unique <- gdh_ridges |> 
  group_by(distrito_2013) |> 
  mutate(
    municipio_2013_f = as.factor(municipio_2013)
    )
  )
  # filter(
  #   distrito_2013 == NA
  # ) 

ridges_plot <- gdh_ridges |> 
  filter(
    cod_dist_chr.x != "99",
    cod_conc_chr.x != "99" 
  )

p6 <- ridges_plot |>
  group_by(regiao_2024) |> 
  ggplot(aes(x = idade, y = regiao_2024)) + 
  geom_density_ridges() +
  theme_classic()

p6


p6_1 <- ridges_plot |>
  group_by(uls_2024) |> 
  ggplot(aes(x = idade, y = uls_2024)) + 
  geom_density_ridges() +
  facet_wrap(~regiao_2024) +
  theme_classic()

p6_1

# fazer por distrito 

p6_2 <- ridges_plot |>
  group_by(dsp) |> 
  ggplot(aes(x = idade, y = dsp)) + 
  geom_density_ridges() +
  theme_classic()

p6_2


p6_7 <- ridges_plot |>
  group_by(sexo) |> 
  ggplot(aes(x = idade, y = sexo)) + 
  geom_density_ridges() +
  theme_classic()

p6_7



dias_int_sum <- var_summarise_df(gdh_base_clean, "dias_int")

dias_int_sum <-  dias_int_sum |> 
  mutate(
    value = round(Value, 2)
  )


p6_3 <- ridges_plot |> 
  filter(
    idade != -1 | dias_int < 10
  ) |> 
  mutate(
    idade_cat = cut(idade, c(0, 18, 65, Inf), right = FALSE)
  ) |> 
  group_by(idade_cat) |> 
  ggplot(aes(x = dias_int, y = idade_cat)) + 
  geom_density_ridges() +
  theme_classic()
  
p6_3
```
